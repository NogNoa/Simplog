/* Declaration Syntax */

keywords:
                        terms           statements
    defined/proved      def(ine)        pr(o)v(e)

    un[defin|prov]ed    prim(itive)     let
    
    well formed         form(ula)       syn(tax)

prim <statement>
prim <term>
syn {syn <statement>}
prim ?=
syn {form <term>?=<term>}


prim :
form {<term>:<statement>}
prim ;
syn {<term>;<statment>}

syn {prim <term>}
syn {let <statement>}

syn {def <term>;<statement>}

prim <type-term>
prim <object-term>
syn {<object-term> \is <type-term>}

prim \and
syn {<statement> \and <statement>}

prim ,
form{<term>, <term>}
form {(a, b: s) :{a:\is <term> \and b:\is <term> \and s:\is statement} ?= a:s, b:s}
form {(a, b: s) :{a,b:\is <term> \and s:\is statement} ?= a:s, b:s}

prim <relation>
let {?=,\is,, \is <relation>}
form {(t: r g): t,g \is <term> \and r \is <relation> ?= t: t r g}


/*
The type of a term need to be mentioned only if it's not implied from syntax of a positive statement regarding it. The statement hold true for all implied types.

Terms that are in english rather than symbolic have to be enclosed by <>, following the example of BNF.
Escaped english words are stand-ins for symbols so they don't have to have to be enclosed by them.

The keywords and ; require enclosing their compound arguments (statements or terms) in {} rather than (). The arguments of : could be eclosed by just ().

Overloading is possible, that is- defining a term multiple times for different contexts

{prim <object-term> O} imply {\exist O}
*/

/* Argument syntax */
prim |
syn {<statement> \trfr <statement>}
syn {prv {(T:\is <statement>)| {(S:\is <statement>) \trfr T}}}
syn {prv {(T:\is <statement>)|{\not T \trfr false}}}
syn {prv {(S:\is <statement>) \than T|{S \trfr T}}}

/*
\trfr is transitive. so {A \trfr B \trfr C} could be reduced to {A \trfr C}

\trfr is also enclosed in {}
*/
